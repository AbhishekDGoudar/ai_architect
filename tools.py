import os
import io
import contextlib
import time
import shutil
import tempfile
import sys

try:
    from cookiecutter.main import cookiecutter
    HAS_COOKIECUTTER = True
except ImportError:
    HAS_COOKIECUTTER = False

def run_diagram_code(code_str: str, filename="architecture_diagram"):
    """
    Executes the generated diagram code in a temporary directory to ensure 
    the output file is captured correctly, regardless of what the LLM names it.
    """
    try:
        # 1. Clean the code string
        clean_code = code_str.replace("```python", "").replace("```", "").strip()
        
        # 2. Define safe execution environment imports
        # Note: We inject a specific filename into the Diagram context if possible, 
        # but reliability is higher if we just catch whatever PNG is made.
        exec_globals = {}
        common_imports = """
from diagrams import Diagram, Cluster, Edge
from diagrams.aws.compute import EC2, ECS, EKS, Lambda
from diagrams.aws.database import RDS, DynamoDB, ElastiCache, Redshift
from diagrams.aws.network import ELB, Route53, VPC, APIGateway
from diagrams.aws.storage import S3, EBS
from diagrams.aws.integration import SQS, SNS
from diagrams.onprem.compute import Server
from diagrams.onprem.database import PostgreSQL, MongoDB, Redis, Cassandra
from diagrams.onprem.queue import Kafka
from diagrams.programming.language import Python, Go, Java, Nodejs
from diagrams.programming.framework import React, Angular, Vue
"""
        exec(common_imports, exec_globals)
        
        # 3. Execute in a temporary directory to isolate the output
        current_dir = os.getcwd()
        generated_image_path = None
        
        with tempfile.TemporaryDirectory() as temp_dir:
            # Change to temp dir so 'diagrams' lib saves there
            os.chdir(temp_dir)
            
            try:
                # Capture stdout to prevent clutter
                output_buffer = io.StringIO()
                with contextlib.redirect_stdout(output_buffer), contextlib.redirect_stderr(output_buffer):
                     exec(clean_code, exec_globals)
                
                # Find any PNG generated
                files = [f for f in os.listdir('.') if f.endswith('.png')]
                if files:
                    # Sort by modification time just in case, though temp dir is fresh
                    files.sort(key=os.path.getmtime, reverse=True)
                    newest_file = files[0]
                    
                    # Move to actual output location
                    final_path = os.path.join(current_dir, f"{filename}.png")
                    shutil.move(newest_file, final_path)
                    generated_image_path = f"{filename}.png"
            except Exception as e:
                return f"Execution Error: {str(e)}"
            finally:
                # Always restore CWD
                os.chdir(current_dir)
        
        if generated_image_path:
            return generated_image_path
            
        return "Error: No PNG generated by the code."

    except Exception as e:
        return f"Diagram System Error: {str(e)}"

def generate_scaffold(structure, output_dir="./output_project") -> list[str]:
    logs = []
    if structure.cookiecutter_url and "http" in structure.cookiecutter_url and HAS_COOKIECUTTER:
        try:
            cookiecutter(structure.cookiecutter_url, output_dir=output_dir, no_input=True)
            logs.append(f"‚úÖ Hydrated template from {structure.cookiecutter_url}")
        except Exception as e: logs.append(f"‚ö†Ô∏è Cookiecutter failed: {e}")

    base_path = os.path.join(output_dir, "generated_app") 
    for file_spec in structure.starter_files:
        try:
            full_path = os.path.join(base_path, file_spec.filename)
            os.makedirs(os.path.dirname(full_path), exist_ok=True)
            with open(full_path, "w", encoding="utf-8") as f: f.write(file_spec.content)
            logs.append(f"üìÑ Created {file_spec.filename}")
        except Exception as e: logs.append(f"‚ùå Failed to write {file_spec.filename}: {e}")
            
    logs.append(f"‚úÖ Scaffolding complete in {base_path}")
    return logs